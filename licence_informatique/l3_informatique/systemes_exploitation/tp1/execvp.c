#include <sys/types.h> // pour pid_t
#include <unistd.h> // pour fork()
#include <stdlib.h> // pour exit()
#include <stdio.h> // pour printf()
#include <sys/wait.h> // pour wait()

/* int traiter(char* prog, char** args,int nbf) {
    pid_t fils_pid;

    // boucle affichant le nombre de fils demandée
    for(int i=0; i<nbf; i++) {
        switch (fils_pid=fork()) {
        case -1: // échec du fork 
            fprintf(stderr, "échec du fork \n");
            perror("fork");
            exit(-1);
        case 0: // code du fils
            printf("mon pid est : %d et le pid pere est : %d \n", getpid(), getppid());
            execvp (prog, args);
            exit(0);
        default: // code du père 
            printf("%d : je suis le père, création du fils réussie\n", getpid());
        }
        // affiche le pid du fils qui vient de se terminer
        while((fils_pid=wait(NULL))>0)
            printf("fin du fils %d \n\n", fils_pid);        
    }
    // sleep(5); laisse le programme tourner pour afficher les zombies
    return 0;
}*/

int traiter(char* prog, char** args) {
    pid_t fils_pid;
    fils_pid=fork(); // créer un processus fils
    if(fils_pid != 0) // père retourne le PID du fils
    return fils_pid;
    else {
    // Fils se charge d’exécuter prog
    execvp (prog, args);
    // Retourner -1 en cas d’erreur
    perror("Erreur dans execvp\n");
    return -1;
    }
}
int main(int argc, char* argv[]) {
    int ret;
    char* cmd;
    printf("\n");
    // Liste d’arguments pour la commande “ls”
    // char* args[] = { "ls", "-l", "/", NULL };
    cmd=argv[1];
    for (int i=1; i<argc; i++) {
        argv[i-1]=argv[i];
    }
    // char* args[] = { tab[], NULL };
    // argv[0] = nom de l’exécutable
    // La liste doit se terminer par NULL

    // traiter crée un processus fils pour exécuter la commande “ls -l /”
    // ret = traiter("ls", args, nombre_fils);
    ret = traiter(cmd, argv);
    printf("processus principal %d termine avec ret=%d\n", getpid(), ret);
    wait(NULL);
    return 0;
}